/* tslint:disable */
/* eslint-disable */
/**
 * Harness feature flag service client apis
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: cf@harness.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AuthenticationRequest
 */
export interface AuthenticationRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationRequest
     */
    apiKey: string;
    /**
     * 
     * @type {AuthenticationRequestTarget}
     * @memberof AuthenticationRequest
     */
    target?: AuthenticationRequestTarget;
}
/**
 * 
 * @export
 * @interface AuthenticationRequestTarget
 */
export interface AuthenticationRequestTarget {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationRequestTarget
     */
    identifier: string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationRequestTarget
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthenticationRequestTarget
     */
    anonymous?: boolean;
    /**
     * 
     * @type {object}
     * @memberof AuthenticationRequestTarget
     */
    attributes?: object;
}
/**
 * 
 * @export
 * @interface AuthenticationResponse
 */
export interface AuthenticationResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResponse
     */
    authToken: string;
}
/**
 * A clause describes what conditions are used to evaluate a flag
 * @export
 * @interface Clause
 */
export interface Clause {
    /**
     * The unique ID for the clause
     * @type {string}
     * @memberof Clause
     */
    id?: string;
    /**
     * The attribute to use in the clause.  This can be any target attribute
     * @type {string}
     * @memberof Clause
     */
    attribute: string;
    /**
     * The type of operation such as equals, starts_with, contains
     * @type {string}
     * @memberof Clause
     */
    op: string;
    /**
     * The values that are compared against the operator
     * @type {Array<string>}
     * @memberof Clause
     */
    values: Array<string>;
    /**
     * Is the operation negated?
     * @type {boolean}
     * @memberof Clause
     */
    negate: boolean;
}
/**
 * Describes a distribution rule
 * @export
 * @interface Distribution
 */
export interface Distribution {
    /**
     * The attribute to use when distributing targets across buckets
     * @type {string}
     * @memberof Distribution
     */
    bucketBy: string;
    /**
     * A list of variations and the weight that should be given to each
     * @type {Array<WeightedVariation>}
     * @memberof Distribution
     */
    variations: Array<WeightedVariation>;
}
/**
 * 
 * @export
 * @interface Evaluation
 */
export interface Evaluation {
    /**
     * 
     * @type {string}
     * @memberof Evaluation
     */
    flag: string;
    /**
     * 
     * @type {string}
     * @memberof Evaluation
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof Evaluation
     */
    kind: string;
    /**
     * 
     * @type {string}
     * @memberof Evaluation
     */
    identifier?: string;
}
/**
 * 
 * @export
 * @interface FeatureConfig
 */
export interface FeatureConfig {
    /**
     * 
     * @type {string}
     * @memberof FeatureConfig
     */
    project: string;
    /**
     * 
     * @type {string}
     * @memberof FeatureConfig
     */
    environment: string;
    /**
     * 
     * @type {string}
     * @memberof FeatureConfig
     */
    feature: string;
    /**
     * 
     * @type {FeatureState}
     * @memberof FeatureConfig
     */
    state: FeatureState;
    /**
     * 
     * @type {string}
     * @memberof FeatureConfig
     */
    kind: FeatureConfigKindEnum;
    /**
     * 
     * @type {Array<Variation>}
     * @memberof FeatureConfig
     */
    variations: Array<Variation>;
    /**
     * 
     * @type {Array<ServingRule>}
     * @memberof FeatureConfig
     */
    rules?: Array<ServingRule>;
    /**
     * 
     * @type {Serve}
     * @memberof FeatureConfig
     */
    defaultServe: Serve;
    /**
     * 
     * @type {string}
     * @memberof FeatureConfig
     */
    offVariation: string;
    /**
     * 
     * @type {Array<Prerequisite>}
     * @memberof FeatureConfig
     */
    prerequisites?: Array<Prerequisite>;
    /**
     * 
     * @type {Array<VariationMap>}
     * @memberof FeatureConfig
     */
    variationToTargetMap?: Array<VariationMap>;
    /**
     * 
     * @type {number}
     * @memberof FeatureConfig
     */
    version?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum FeatureConfigKindEnum {
    Boolean = 'boolean',
    Int = 'int',
    String = 'string',
    Json = 'json'
}

/**
 * The state of a flag either off or on
 * @export
 * @enum {string}
 */

export enum FeatureState {
    On = 'on',
    Off = 'off'
}

/**
 * The rule used to determine what variation to serve to a target
 * @export
 * @interface GroupServingRule
 */
export interface GroupServingRule {
    /**
     * The unique identifier for this rule
     * @type {string}
     * @memberof GroupServingRule
     */
    ruleId: string;
    /**
     * The rules priority relative to other rules.  The rules are evaluated in order with 1 being the highest
     * @type {number}
     * @memberof GroupServingRule
     */
    priority: number;
    /**
     * A list of clauses to use in the rule
     * @type {Array<Clause>}
     * @memberof GroupServingRule
     */
    clauses: Array<Clause>;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    proxyKey: string;
}
/**
 * 
 * @export
 * @interface KeyValue
 */
export interface KeyValue {
    /**
     * 
     * @type {string}
     * @memberof KeyValue
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof KeyValue
     */
    value: string;
}
/**
 * 
 * @export
 * @interface Metrics
 */
export interface Metrics {
    /**
     * 
     * @type {Array<TargetData>}
     * @memberof Metrics
     */
    targetData?: Array<TargetData>;
    /**
     * 
     * @type {Array<MetricsData>}
     * @memberof Metrics
     */
    metricsData?: Array<MetricsData>;
}
/**
 * 
 * @export
 * @interface MetricsData
 */
export interface MetricsData {
    /**
     * time at when this data was recorded
     * @type {number}
     * @memberof MetricsData
     */
    timestamp: number;
    /**
     * 
     * @type {number}
     * @memberof MetricsData
     */
    count: number;
    /**
     * This can be of type FeatureMetrics
     * @type {string}
     * @memberof MetricsData
     */
    metricsType: MetricsDataMetricsTypeEnum;
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof MetricsData
     */
    attributes: Array<KeyValue>;
}

/**
    * @export
    * @enum {string}
    */
export enum MetricsDataMetricsTypeEnum {
    Ffmetrics = 'FFMETRICS'
}

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * The http error code
     * @type {string}
     * @memberof ModelError
     */
    code: string;
    /**
     * The reason the request failed
     * @type {string}
     * @memberof ModelError
     */
    message: string;
    /**
     * Additional details about the error
     * @type {object}
     * @memberof ModelError
     */
    details?: object;
}
/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * The version of this object.  The version will be incremented each time the object is modified
     * @type {number}
     * @memberof Pagination
     */
    version?: number;
    /**
     * The total number of pages
     * @type {number}
     * @memberof Pagination
     */
    pageCount: number;
    /**
     * The total number of items
     * @type {number}
     * @memberof Pagination
     */
    itemCount: number;
    /**
     * The number of items per page
     * @type {number}
     * @memberof Pagination
     */
    pageSize: number;
    /**
     * The current page
     * @type {number}
     * @memberof Pagination
     */
    pageIndex: number;
}
/**
 * Feature Flag pre-requisites
 * @export
 * @interface Prerequisite
 */
export interface Prerequisite {
    /**
     * The feature identifier that is the prerequisite
     * @type {string}
     * @memberof Prerequisite
     */
    feature: string;
    /**
     * A list of variations that must be met
     * @type {Array<string>}
     * @memberof Prerequisite
     */
    variations: Array<string>;
}
/**
 * TBD
 * @export
 * @interface ProxyConfig
 */
export interface ProxyConfig {
    /**
     * The version of this object.  The version will be incremented each time the object is modified
     * @type {number}
     * @memberof ProxyConfig
     */
    version?: number;
    /**
     * The total number of pages
     * @type {number}
     * @memberof ProxyConfig
     */
    pageCount: number;
    /**
     * The total number of items
     * @type {number}
     * @memberof ProxyConfig
     */
    itemCount: number;
    /**
     * The number of items per page
     * @type {number}
     * @memberof ProxyConfig
     */
    pageSize: number;
    /**
     * The current page
     * @type {number}
     * @memberof ProxyConfig
     */
    pageIndex: number;
    /**
     * 
     * @type {Array<ProxyConfigAllOfEnvironments>}
     * @memberof ProxyConfig
     */
    environments?: Array<ProxyConfigAllOfEnvironments>;
}
/**
 * 
 * @export
 * @interface ProxyConfigAllOf
 */
export interface ProxyConfigAllOf {
    /**
     * 
     * @type {Array<ProxyConfigAllOfEnvironments>}
     * @memberof ProxyConfigAllOf
     */
    environments?: Array<ProxyConfigAllOfEnvironments>;
}
/**
 * 
 * @export
 * @interface ProxyConfigAllOfEnvironments
 */
export interface ProxyConfigAllOfEnvironments {
    /**
     * 
     * @type {string}
     * @memberof ProxyConfigAllOfEnvironments
     */
    id?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProxyConfigAllOfEnvironments
     */
    apiKeys?: Array<string>;
    /**
     * 
     * @type {Array<FeatureConfig>}
     * @memberof ProxyConfigAllOfEnvironments
     */
    featureConfigs?: Array<FeatureConfig>;
    /**
     * 
     * @type {Array<Segment>}
     * @memberof ProxyConfigAllOfEnvironments
     */
    segments?: Array<Segment>;
}
/**
 * A Target Group (Segment) response
 * @export
 * @interface Segment
 */
export interface Segment {
    /**
     * Unique identifier for the target group.
     * @type {string}
     * @memberof Segment
     */
    identifier: string;
    /**
     * Name of the target group.
     * @type {string}
     * @memberof Segment
     */
    name: string;
    /**
     * The environment this target group belongs to
     * @type {string}
     * @memberof Segment
     */
    environment?: string;
    /**
     * Tags for this target group
     * @type {Array<Tag>}
     * @memberof Segment
     */
    tags?: Array<Tag>;
    /**
     * A list of Targets who belong to this target group
     * @type {Array<Target>}
     * @memberof Segment
     */
    included?: Array<Target>;
    /**
     * A list of Targets who are excluded from this target group
     * @type {Array<Target>}
     * @memberof Segment
     */
    excluded?: Array<Target>;
    /**
     * 
     * @type {Array<Clause>}
     * @memberof Segment
     */
    rules?: Array<Clause>;
    /**
     * An array of rules that can cause a user to be included in this segment.
     * @type {Array<GroupServingRule>}
     * @memberof Segment
     */
    servingRules?: Array<GroupServingRule>;
    /**
     * The data and time in milliseconds when the group was created
     * @type {number}
     * @memberof Segment
     */
    createdAt?: number;
    /**
     * The data and time in milliseconds when the group was last modified
     * @type {number}
     * @memberof Segment
     */
    modifiedAt?: number;
    /**
     * The version of this group.  Each time it is modified the version is incremented
     * @type {number}
     * @memberof Segment
     */
    version?: number;
}
/**
 * Describe the distribution rule and the variation that should be served to the target
 * @export
 * @interface Serve
 */
export interface Serve {
    /**
     * 
     * @type {Distribution}
     * @memberof Serve
     */
    distribution?: Distribution;
    /**
     * 
     * @type {string}
     * @memberof Serve
     */
    variation?: string;
}
/**
 * The rule used to determine what variation to serve to a target
 * @export
 * @interface ServingRule
 */
export interface ServingRule {
    /**
     * The unique identifier for this rule
     * @type {string}
     * @memberof ServingRule
     */
    ruleId?: string;
    /**
     * The rules priority relative to other rules.  The rules are evaluated in order with 1 being the highest
     * @type {number}
     * @memberof ServingRule
     */
    priority: number;
    /**
     * A list of clauses to use in the rule
     * @type {Array<Clause>}
     * @memberof ServingRule
     */
    clauses: Array<Clause>;
    /**
     * 
     * @type {Serve}
     * @memberof ServingRule
     */
    serve: Serve;
}
/**
 * A Tag object used to tag feature flags - consists of name and identifier
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * The name of the tag
     * @type {string}
     * @memberof Tag
     */
    name: string;
    /**
     * The identifier of the tag
     * @type {string}
     * @memberof Tag
     */
    identifier: string;
}
/**
 * A Target object
 * @export
 * @interface Target
 */
export interface Target {
    /**
     * The unique identifier for this target
     * @type {string}
     * @memberof Target
     */
    identifier: string;
    /**
     * The account ID that the target belongs to
     * @type {string}
     * @memberof Target
     */
    account: string;
    /**
     * The identifier for the organization that the target belongs to
     * @type {string}
     * @memberof Target
     */
    org: string;
    /**
     * The identifier for the environment that the target belongs to
     * @type {string}
     * @memberof Target
     */
    environment: string;
    /**
     * The identifier for the project that this target belongs to
     * @type {string}
     * @memberof Target
     */
    project: string;
    /**
     * The name of this Target
     * @type {string}
     * @memberof Target
     */
    name: string;
    /**
     * Indicates if this target is anonymous
     * @type {boolean}
     * @memberof Target
     */
    anonymous?: boolean;
    /**
     * a JSON representation of the attributes for this target
     * @type {object}
     * @memberof Target
     */
    attributes?: object;
    /**
     * The date and time in milliseconds when this Target was created
     * @type {number}
     * @memberof Target
     */
    createdAt?: number;
    /**
     * A list of Target Groups (Segments) that this Target belongs to
     * @type {Array<Segment>}
     * @memberof Target
     */
    segments?: Array<Segment>;
}
/**
 * 
 * @export
 * @interface TargetData
 */
export interface TargetData {
    /**
     * 
     * @type {string}
     * @memberof TargetData
     */
    identifier: string;
    /**
     * 
     * @type {string}
     * @memberof TargetData
     */
    name: string;
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof TargetData
     */
    attributes: Array<KeyValue>;
}
/**
 * Target map provides the details of a target that belongs to a flag
 * @export
 * @interface TargetMap
 */
export interface TargetMap {
    /**
     * The identifier for the target
     * @type {string}
     * @memberof TargetMap
     */
    identifier: string;
    /**
     * The name of the target
     * @type {string}
     * @memberof TargetMap
     */
    name: string;
}
/**
 * A variation of a flag that can be returned to a target
 * @export
 * @interface Variation
 */
export interface Variation {
    /**
     * The unique identifier for the variation
     * @type {string}
     * @memberof Variation
     */
    identifier: string;
    /**
     * The variation value to serve such as true or false for a boolean flag
     * @type {string}
     * @memberof Variation
     */
    value: string;
    /**
     * The user friendly name of the variation
     * @type {string}
     * @memberof Variation
     */
    name?: string;
    /**
     * A description of the variation
     * @type {string}
     * @memberof Variation
     */
    description?: string;
}
/**
 * A mapping of variations to targets and target groups (segments).  The targets listed here should receive this variation.
 * @export
 * @interface VariationMap
 */
export interface VariationMap {
    /**
     * The variation identifier
     * @type {string}
     * @memberof VariationMap
     */
    variation: string;
    /**
     * A list of target mappings
     * @type {Array<TargetMap>}
     * @memberof VariationMap
     */
    targets?: Array<TargetMap>;
    /**
     * A list of target groups (segments)
     * @type {Array<string>}
     * @memberof VariationMap
     */
    targetSegments?: Array<string>;
}
/**
 * A variation and the weighting it should receive as part of a percentage rollout
 * @export
 * @interface WeightedVariation
 */
export interface WeightedVariation {
    /**
     * The variation identifier
     * @type {string}
     * @memberof WeightedVariation
     */
    variation: string;
    /**
     * The weight to be given to the variation in percent
     * @type {number}
     * @memberof WeightedVariation
     */
    weight: number;
}

/**
 * ClientApi - axios parameter creator
 * @export
 */
export const ClientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Used to retrieve all target segments for certain account id.
         * @summary Authenticate with the admin server.
         * @param {AuthenticationRequest} [authenticationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate: async (authenticationRequest?: AuthenticationRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/client/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to retrieve all segments for certain account id.
         * @summary Retrieve all segments.
         * @param {string} environmentUUID Unique identifier for the environment object in the API.
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {string} [rules] When set to rules&#x3D;v2 will return AND rule compatible serving_rules field. When not set or set to any other value will return old rules field only compatible with OR rules.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSegments: async (environmentUUID: string, cluster?: string, rules?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentUUID' is not null or undefined
            assertParamExists('getAllSegments', 'environmentUUID', environmentUUID)
            const localVarPath = `/client/env/{environmentUUID}/target-segments`
                .replace(`{${"environmentUUID"}}`, encodeURIComponent(String(environmentUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (rules !== undefined) {
                localVarQueryParameter['rules'] = rules;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get feature evaluations for target
         * @param {string} environmentUUID Unique identifier for the environment object in the API.
         * @param {string} feature Unique identifier for the flag object in the API.
         * @param {string} target Unique identifier for the target object in the API.
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluationByIdentifier: async (environmentUUID: string, feature: string, target: string, cluster?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentUUID' is not null or undefined
            assertParamExists('getEvaluationByIdentifier', 'environmentUUID', environmentUUID)
            // verify required parameter 'feature' is not null or undefined
            assertParamExists('getEvaluationByIdentifier', 'feature', feature)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('getEvaluationByIdentifier', 'target', target)
            const localVarPath = `/client/env/{environmentUUID}/target/{target}/evaluations/{feature}`
                .replace(`{${"environmentUUID"}}`, encodeURIComponent(String(environmentUUID)))
                .replace(`{${"feature"}}`, encodeURIComponent(String(feature)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get feature evaluations for target
         * @param {string} environmentUUID Unique identifier for the environment object in the API.
         * @param {string} target Unique identifier for the target object in the API.
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluations: async (environmentUUID: string, target: string, cluster?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentUUID' is not null or undefined
            assertParamExists('getEvaluations', 'environmentUUID', environmentUUID)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('getEvaluations', 'target', target)
            const localVarPath = `/client/env/{environmentUUID}/target/{target}/evaluations`
                .replace(`{${"environmentUUID"}}`, encodeURIComponent(String(environmentUUID)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * All feature flags with activations in project environment
         * @summary Get all feature flags activations
         * @param {string} environmentUUID Unique identifier for the environment object in the API.
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureConfig: async (environmentUUID: string, cluster?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentUUID' is not null or undefined
            assertParamExists('getFeatureConfig', 'environmentUUID', environmentUUID)
            const localVarPath = `/client/env/{environmentUUID}/feature-configs`
                .replace(`{${"environmentUUID"}}`, encodeURIComponent(String(environmentUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get feature config
         * @param {string} identifier Unique identifier for the flag object in the API.
         * @param {string} environmentUUID Unique identifier for the environment object in the API.
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureConfigByIdentifier: async (identifier: string, environmentUUID: string, cluster?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('getFeatureConfigByIdentifier', 'identifier', identifier)
            // verify required parameter 'environmentUUID' is not null or undefined
            assertParamExists('getFeatureConfigByIdentifier', 'environmentUUID', environmentUUID)
            const localVarPath = `/client/env/{environmentUUID}/feature-configs/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"environmentUUID"}}`, encodeURIComponent(String(environmentUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Used to retrieve a segment for a certain account id by identifier
         * @summary Retrieve a segment by identifier
         * @param {string} identifier Unique identifier for the segment object in the API
         * @param {string} environmentUUID Unique identifier for the environment object in the API
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {string} [rules] When set to rules&#x3D;v2 will return AND rule compatible serving_rules field. When not set or set to any other value will return old rules field only compatible with OR rules.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentByIdentifier: async (identifier: string, environmentUUID: string, cluster?: string, rules?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            assertParamExists('getSegmentByIdentifier', 'identifier', identifier)
            // verify required parameter 'environmentUUID' is not null or undefined
            assertParamExists('getSegmentByIdentifier', 'environmentUUID', environmentUUID)
            const localVarPath = `/client/env/{environmentUUID}/target-segments/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"environmentUUID"}}`, encodeURIComponent(String(environmentUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (rules !== undefined) {
                localVarQueryParameter['rules'] = rules;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stream endpoint.
         * @param {string} aPIKey 
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stream: async (aPIKey: string, cluster?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'aPIKey' is not null or undefined
            assertParamExists('stream', 'aPIKey', aPIKey)
            const localVarPath = `/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (aPIKey !== undefined && aPIKey !== null) {
                localVarHeaderParameter['API-Key'] = String(aPIKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientApi - functional programming interface
 * @export
 */
export const ClientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientApiAxiosParamCreator(configuration)
    return {
        /**
         * Used to retrieve all target segments for certain account id.
         * @summary Authenticate with the admin server.
         * @param {AuthenticationRequest} [authenticationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticate(authenticationRequest?: AuthenticationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(authenticationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Used to retrieve all segments for certain account id.
         * @summary Retrieve all segments.
         * @param {string} environmentUUID Unique identifier for the environment object in the API.
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {string} [rules] When set to rules&#x3D;v2 will return AND rule compatible serving_rules field. When not set or set to any other value will return old rules field only compatible with OR rules.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSegments(environmentUUID: string, cluster?: string, rules?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Segment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSegments(environmentUUID, cluster, rules, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get feature evaluations for target
         * @param {string} environmentUUID Unique identifier for the environment object in the API.
         * @param {string} feature Unique identifier for the flag object in the API.
         * @param {string} target Unique identifier for the target object in the API.
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvaluationByIdentifier(environmentUUID: string, feature: string, target: string, cluster?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Evaluation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvaluationByIdentifier(environmentUUID, feature, target, cluster, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get feature evaluations for target
         * @param {string} environmentUUID Unique identifier for the environment object in the API.
         * @param {string} target Unique identifier for the target object in the API.
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEvaluations(environmentUUID: string, target: string, cluster?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pagination & Array>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEvaluations(environmentUUID, target, cluster, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * All feature flags with activations in project environment
         * @summary Get all feature flags activations
         * @param {string} environmentUUID Unique identifier for the environment object in the API.
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureConfig(environmentUUID: string, cluster?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FeatureConfig>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureConfig(environmentUUID, cluster, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get feature config
         * @param {string} identifier Unique identifier for the flag object in the API.
         * @param {string} environmentUUID Unique identifier for the environment object in the API.
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeatureConfigByIdentifier(identifier: string, environmentUUID: string, cluster?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeatureConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeatureConfigByIdentifier(identifier, environmentUUID, cluster, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Used to retrieve a segment for a certain account id by identifier
         * @summary Retrieve a segment by identifier
         * @param {string} identifier Unique identifier for the segment object in the API
         * @param {string} environmentUUID Unique identifier for the environment object in the API
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {string} [rules] When set to rules&#x3D;v2 will return AND rule compatible serving_rules field. When not set or set to any other value will return old rules field only compatible with OR rules.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegmentByIdentifier(identifier: string, environmentUUID: string, cluster?: string, rules?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Segment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSegmentByIdentifier(identifier, environmentUUID, cluster, rules, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stream endpoint.
         * @param {string} aPIKey 
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stream(aPIKey: string, cluster?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stream(aPIKey, cluster, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClientApi - factory interface
 * @export
 */
export const ClientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientApiFp(configuration)
    return {
        /**
         * Used to retrieve all target segments for certain account id.
         * @summary Authenticate with the admin server.
         * @param {AuthenticationRequest} [authenticationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(authenticationRequest?: AuthenticationRequest, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.authenticate(authenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to retrieve all segments for certain account id.
         * @summary Retrieve all segments.
         * @param {string} environmentUUID Unique identifier for the environment object in the API.
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {string} [rules] When set to rules&#x3D;v2 will return AND rule compatible serving_rules field. When not set or set to any other value will return old rules field only compatible with OR rules.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSegments(environmentUUID: string, cluster?: string, rules?: string, options?: any): AxiosPromise<Array<Segment>> {
            return localVarFp.getAllSegments(environmentUUID, cluster, rules, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get feature evaluations for target
         * @param {string} environmentUUID Unique identifier for the environment object in the API.
         * @param {string} feature Unique identifier for the flag object in the API.
         * @param {string} target Unique identifier for the target object in the API.
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluationByIdentifier(environmentUUID: string, feature: string, target: string, cluster?: string, options?: any): AxiosPromise<Evaluation> {
            return localVarFp.getEvaluationByIdentifier(environmentUUID, feature, target, cluster, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get feature evaluations for target
         * @param {string} environmentUUID Unique identifier for the environment object in the API.
         * @param {string} target Unique identifier for the target object in the API.
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvaluations(environmentUUID: string, target: string, cluster?: string, options?: any): AxiosPromise<Pagination & Array> {
            return localVarFp.getEvaluations(environmentUUID, target, cluster, options).then((request) => request(axios, basePath));
        },
        /**
         * All feature flags with activations in project environment
         * @summary Get all feature flags activations
         * @param {string} environmentUUID Unique identifier for the environment object in the API.
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureConfig(environmentUUID: string, cluster?: string, options?: any): AxiosPromise<Array<FeatureConfig>> {
            return localVarFp.getFeatureConfig(environmentUUID, cluster, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get feature config
         * @param {string} identifier Unique identifier for the flag object in the API.
         * @param {string} environmentUUID Unique identifier for the environment object in the API.
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureConfigByIdentifier(identifier: string, environmentUUID: string, cluster?: string, options?: any): AxiosPromise<FeatureConfig> {
            return localVarFp.getFeatureConfigByIdentifier(identifier, environmentUUID, cluster, options).then((request) => request(axios, basePath));
        },
        /**
         * Used to retrieve a segment for a certain account id by identifier
         * @summary Retrieve a segment by identifier
         * @param {string} identifier Unique identifier for the segment object in the API
         * @param {string} environmentUUID Unique identifier for the environment object in the API
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {string} [rules] When set to rules&#x3D;v2 will return AND rule compatible serving_rules field. When not set or set to any other value will return old rules field only compatible with OR rules.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentByIdentifier(identifier: string, environmentUUID: string, cluster?: string, rules?: string, options?: any): AxiosPromise<Segment> {
            return localVarFp.getSegmentByIdentifier(identifier, environmentUUID, cluster, rules, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stream endpoint.
         * @param {string} aPIKey 
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stream(aPIKey: string, cluster?: string, options?: any): AxiosPromise<void> {
            return localVarFp.stream(aPIKey, cluster, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientApi - object-oriented interface
 * @export
 * @class ClientApi
 * @extends {BaseAPI}
 */
export class ClientApi extends BaseAPI {
    /**
     * Used to retrieve all target segments for certain account id.
     * @summary Authenticate with the admin server.
     * @param {AuthenticationRequest} [authenticationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public authenticate(authenticationRequest?: AuthenticationRequest, options?: any) {
        return ClientApiFp(this.configuration).authenticate(authenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to retrieve all segments for certain account id.
     * @summary Retrieve all segments.
     * @param {string} environmentUUID Unique identifier for the environment object in the API.
     * @param {string} [cluster] Unique identifier for the cluster for the account
     * @param {string} [rules] When set to rules&#x3D;v2 will return AND rule compatible serving_rules field. When not set or set to any other value will return old rules field only compatible with OR rules.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public getAllSegments(environmentUUID: string, cluster?: string, rules?: string, options?: any) {
        return ClientApiFp(this.configuration).getAllSegments(environmentUUID, cluster, rules, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get feature evaluations for target
     * @param {string} environmentUUID Unique identifier for the environment object in the API.
     * @param {string} feature Unique identifier for the flag object in the API.
     * @param {string} target Unique identifier for the target object in the API.
     * @param {string} [cluster] Unique identifier for the cluster for the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public getEvaluationByIdentifier(environmentUUID: string, feature: string, target: string, cluster?: string, options?: any) {
        return ClientApiFp(this.configuration).getEvaluationByIdentifier(environmentUUID, feature, target, cluster, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get feature evaluations for target
     * @param {string} environmentUUID Unique identifier for the environment object in the API.
     * @param {string} target Unique identifier for the target object in the API.
     * @param {string} [cluster] Unique identifier for the cluster for the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public getEvaluations(environmentUUID: string, target: string, cluster?: string, options?: any) {
        return ClientApiFp(this.configuration).getEvaluations(environmentUUID, target, cluster, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * All feature flags with activations in project environment
     * @summary Get all feature flags activations
     * @param {string} environmentUUID Unique identifier for the environment object in the API.
     * @param {string} [cluster] Unique identifier for the cluster for the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public getFeatureConfig(environmentUUID: string, cluster?: string, options?: any) {
        return ClientApiFp(this.configuration).getFeatureConfig(environmentUUID, cluster, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get feature config
     * @param {string} identifier Unique identifier for the flag object in the API.
     * @param {string} environmentUUID Unique identifier for the environment object in the API.
     * @param {string} [cluster] Unique identifier for the cluster for the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public getFeatureConfigByIdentifier(identifier: string, environmentUUID: string, cluster?: string, options?: any) {
        return ClientApiFp(this.configuration).getFeatureConfigByIdentifier(identifier, environmentUUID, cluster, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Used to retrieve a segment for a certain account id by identifier
     * @summary Retrieve a segment by identifier
     * @param {string} identifier Unique identifier for the segment object in the API
     * @param {string} environmentUUID Unique identifier for the environment object in the API
     * @param {string} [cluster] Unique identifier for the cluster for the account
     * @param {string} [rules] When set to rules&#x3D;v2 will return AND rule compatible serving_rules field. When not set or set to any other value will return old rules field only compatible with OR rules.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public getSegmentByIdentifier(identifier: string, environmentUUID: string, cluster?: string, rules?: string, options?: any) {
        return ClientApiFp(this.configuration).getSegmentByIdentifier(identifier, environmentUUID, cluster, rules, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stream endpoint.
     * @param {string} aPIKey 
     * @param {string} [cluster] Unique identifier for the cluster for the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientApi
     */
    public stream(aPIKey: string, cluster?: string, options?: any) {
        return ClientApiFp(this.configuration).stream(aPIKey, cluster, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetricsApi - axios parameter creator
 * @export
 */
export const MetricsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Send metrics to Analytics server
         * @summary Send metrics to the Analytics server.
         * @param {string} environmentUUID environment parameter in query.
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {Metrics} [metrics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMetrics: async (environmentUUID: string, cluster?: string, metrics?: Metrics, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentUUID' is not null or undefined
            assertParamExists('postMetrics', 'environmentUUID', environmentUUID)
            const localVarPath = `/metrics/{environmentUUID}`
                .replace(`{${"environmentUUID"}}`, encodeURIComponent(String(environmentUUID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "api-key", configuration)

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(metrics, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetricsApiAxiosParamCreator(configuration)
    return {
        /**
         * Send metrics to Analytics server
         * @summary Send metrics to the Analytics server.
         * @param {string} environmentUUID environment parameter in query.
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {Metrics} [metrics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMetrics(environmentUUID: string, cluster?: string, metrics?: Metrics, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMetrics(environmentUUID, cluster, metrics, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetricsApiFp(configuration)
    return {
        /**
         * Send metrics to Analytics server
         * @summary Send metrics to the Analytics server.
         * @param {string} environmentUUID environment parameter in query.
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {Metrics} [metrics] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMetrics(environmentUUID: string, cluster?: string, metrics?: Metrics, options?: any): AxiosPromise<void> {
            return localVarFp.postMetrics(environmentUUID, cluster, metrics, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * Send metrics to Analytics server
     * @summary Send metrics to the Analytics server.
     * @param {string} environmentUUID environment parameter in query.
     * @param {string} [cluster] Unique identifier for the cluster for the account
     * @param {Metrics} [metrics] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public postMetrics(environmentUUID: string, cluster?: string, metrics?: Metrics, options?: any) {
        return MetricsApiFp(this.configuration).postMetrics(environmentUUID, cluster, metrics, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProxyApi - axios parameter creator
 * @export
 */
export const ProxyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Endpoint that the Proxy can use to authenticate with the client server
         * @summary Endpoint that the Proxy can use to authenticate with the client server
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateProxyKey: async (inlineObject?: InlineObject, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/proxy/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets Proxy config for multiple environments if the Key query param is provided or gets config for a single environment if an environment query param is provided
         * @summary Gets Proxy config for multiple environments
         * @param {string} key Accpets a Proxy Key.
         * @param {number} [pageNumber] PageNumber
         * @param {number} [pageSize] PageSize
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {string} [environment] Accepts an EnvironmentID. If this is provided then the endpoint will only return config for this environment. If this is left empty then the Proxy will return config for all environments associated with the Proxy Key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxyConfig: async (key: string, pageNumber?: number, pageSize?: number, cluster?: string, environment?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getProxyConfig', 'key', key)
            const localVarPath = `/proxy/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (environment !== undefined) {
                localVarQueryParameter['environment'] = environment;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProxyApi - functional programming interface
 * @export
 */
export const ProxyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProxyApiAxiosParamCreator(configuration)
    return {
        /**
         * Endpoint that the Proxy can use to authenticate with the client server
         * @summary Endpoint that the Proxy can use to authenticate with the client server
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateProxyKey(inlineObject?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticateProxyKey(inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets Proxy config for multiple environments if the Key query param is provided or gets config for a single environment if an environment query param is provided
         * @summary Gets Proxy config for multiple environments
         * @param {string} key Accpets a Proxy Key.
         * @param {number} [pageNumber] PageNumber
         * @param {number} [pageSize] PageSize
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {string} [environment] Accepts an EnvironmentID. If this is provided then the endpoint will only return config for this environment. If this is left empty then the Proxy will return config for all environments associated with the Proxy Key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProxyConfig(key: string, pageNumber?: number, pageSize?: number, cluster?: string, environment?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProxyConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProxyConfig(key, pageNumber, pageSize, cluster, environment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProxyApi - factory interface
 * @export
 */
export const ProxyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProxyApiFp(configuration)
    return {
        /**
         * Endpoint that the Proxy can use to authenticate with the client server
         * @summary Endpoint that the Proxy can use to authenticate with the client server
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateProxyKey(inlineObject?: InlineObject, options?: any): AxiosPromise<AuthenticationResponse> {
            return localVarFp.authenticateProxyKey(inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets Proxy config for multiple environments if the Key query param is provided or gets config for a single environment if an environment query param is provided
         * @summary Gets Proxy config for multiple environments
         * @param {string} key Accpets a Proxy Key.
         * @param {number} [pageNumber] PageNumber
         * @param {number} [pageSize] PageSize
         * @param {string} [cluster] Unique identifier for the cluster for the account
         * @param {string} [environment] Accepts an EnvironmentID. If this is provided then the endpoint will only return config for this environment. If this is left empty then the Proxy will return config for all environments associated with the Proxy Key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProxyConfig(key: string, pageNumber?: number, pageSize?: number, cluster?: string, environment?: string, options?: any): AxiosPromise<ProxyConfig> {
            return localVarFp.getProxyConfig(key, pageNumber, pageSize, cluster, environment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProxyApi - object-oriented interface
 * @export
 * @class ProxyApi
 * @extends {BaseAPI}
 */
export class ProxyApi extends BaseAPI {
    /**
     * Endpoint that the Proxy can use to authenticate with the client server
     * @summary Endpoint that the Proxy can use to authenticate with the client server
     * @param {InlineObject} [inlineObject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public authenticateProxyKey(inlineObject?: InlineObject, options?: any) {
        return ProxyApiFp(this.configuration).authenticateProxyKey(inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets Proxy config for multiple environments if the Key query param is provided or gets config for a single environment if an environment query param is provided
     * @summary Gets Proxy config for multiple environments
     * @param {string} key Accpets a Proxy Key.
     * @param {number} [pageNumber] PageNumber
     * @param {number} [pageSize] PageSize
     * @param {string} [cluster] Unique identifier for the cluster for the account
     * @param {string} [environment] Accepts an EnvironmentID. If this is provided then the endpoint will only return config for this environment. If this is left empty then the Proxy will return config for all environments associated with the Proxy Key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProxyApi
     */
    public getProxyConfig(key: string, pageNumber?: number, pageSize?: number, cluster?: string, environment?: string, options?: any) {
        return ProxyApiFp(this.configuration).getProxyConfig(key, pageNumber, pageSize, cluster, environment, options).then((request) => request(this.axios, this.basePath));
    }
}


